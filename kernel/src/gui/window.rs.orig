use alloc::string::String;
use alloc::vec::Vec;

use super::{Color, Rect};

const TITLE_BAR_H: i32 = 22;
pub const WINDOW_TITLE_BAR_H: i32 = TITLE_BAR_H;
pub const WINDOW_RESIZE_GRIP: i32 = 16;

const EXPLORER_TOP_H: i32 = 30;
const EXPLORER_STATUS_H: i32 = 58;
const EXPLORER_CELL_W: i32 = 108;
const EXPLORER_CELL_H: i32 = 98;
const EXPLORER_GAP_X: i32 = 14;
const EXPLORER_GAP_Y: i32 = 16;
const EXPLORER_MARGIN_X: i32 = 16;
const EXPLORER_MARGIN_Y: i32 = 38;

const NOTEPAD_TOP_H: i32 = 36;
const NOTEPAD_STATUS_H: i32 = 28;

const BROWSER_TOP_H: i32 = 64;
const BROWSER_STATUS_H: i32 = 24;
const IMAGE_VIEWER_TOP_H: i32 = 52;
const IMAGE_VIEWER_STATUS_H: i32 = 28;
const APP_RUNNER_TOP_H: i32 = 52;
const APP_RUNNER_STATUS_H: i32 = 28;
const DOOM_LAUNCHER_TOP_H: i32 = 52;
const DOOM_LAUNCHER_STATUS_H: i32 = 28;
const LINUX_BRIDGE_TOP_H: i32 = 52;
const LINUX_BRIDGE_STATUS_H: i32 = 28;

#[derive(Copy, Clone, PartialEq)]
pub enum WindowState {
    Normal,
    Minimized,
    Maximized,
    Closed,
}

#[derive(Copy, Clone, PartialEq, Eq)]
pub enum WindowKind {
    Terminal,
    Explorer,
    Notepad,
    Browser,
    ImageViewer,
    AppRunner,
    DoomLauncher,
    LinuxBridge,
    Settings,
}

#[derive(Clone, Copy, PartialEq, Eq)]
pub enum ExplorerItemKind {
    ShortcutDesktop,
    ShortcutDownloads,
    ShortcutDocuments,
    ShortcutImages,
    ShortcutVideos,
    ShortcutUsb,
    ShortcutVolume,
    Home,
    Up,
    Directory,
    File,
}

#[derive(Clone)]
pub struct ExplorerItem {
    pub label: String,
    pub kind: ExplorerItemKind,
    pub cluster: u32,
    pub size: u32,
}

impl ExplorerItem {
    pub fn new(label: &str, kind: ExplorerItemKind, cluster: u32, size: u32) -> Self {
        Self {
            label: String::from(label),
            kind,
            cluster,
            size,
        }
    }
}

#[derive(Clone, Copy, PartialEq, Eq)]
pub enum NotepadClickAction {
    New,
    Save,
    Delete,
    FilenameField,
    EditorArea,
}

pub struct WindowControls {
    pub close_btn: Rect,
    pub minimize_btn: Rect,
    pub maximize_btn: Rect,
}

impl WindowControls {
    pub fn new(win_x: i32, win_y: i32, win_width: u32) -> Self {
        let btn_y = win_y + 3;
        Self {
            close_btn: Rect::new(win_x + win_width as i32 - 18, btn_y, 16, 16),
            minimize_btn: Rect::new(win_x + win_width as i32 - 58, btn_y, 16, 16),
            maximize_btn: Rect::new(win_x + win_width as i32 - 38, btn_y, 16, 16),
        }
    }
}

pub struct Window {
    pub id: usize,
    pub rect: Rect,
    pub title: String,
    pub buffer: Vec<u32>,
    pub state: WindowState,
    pub kind: WindowKind,
    pub controls: WindowControls,
    pub saved_rect: Rect,

    // Terminal state
    pub input_buffer: String,
    pub output_lines: Vec<String>,
    pub cursor_x: usize,
    pub current_dir_cluster: u32,
    pub current_path: String,

    // Explorer state
    pub explorer_items: Vec<ExplorerItem>,
    pub explorer_current_cluster: u32,
    pub explorer_device_index: Option<usize>,
    pub explorer_path: String,
    pub explorer_status: String,
    pub explorer_preview_lines: Vec<String>,

    // Notepad state
    pub notepad_file_name: String,
    pub notepad_text: String,
    pub notepad_status: String,
    pub notepad_dir_cluster: u32,
    pub notepad_dir_path: String,
    pub notepad_edit_name: bool,

    // Browser state
    pub browser_url: String,
    pub browser_status: String,
    pub browser_content_lines: Vec<String>,
    pub browser_scroll: usize,
    pub browser_surface_source: String,
    pub browser_surface_width: u32,
    pub browser_surface_height: u32,
    pub browser_surface_pixels: Vec<u32>,

    // Image Viewer state
    pub image_viewer_file_name: String,
    pub image_viewer_status: String,
    pub image_viewer_width: u32,
    pub image_viewer_height: u32,
    pub image_viewer_pixels: Vec<u32>,

    // App Runner state
    pub app_runner_source_file: String,
    pub app_runner_theme: String,
    pub app_runner_header_text: String,
    pub app_runner_body_text: String,
    pub app_runner_button_label: String,
    pub app_runner_status: String,
    pub app_runner_background_color: u32,
    pub app_runner_header_color: u32,
    pub app_runner_body_color: u32,
    pub app_runner_button_color: u32,

    // DOOM Launcher state
    pub doom_status: String,

    // Linux Bridge state
    pub linux_bridge_status: String,
    pub linux_bridge_source: String,
    pub linux_bridge_width: u32,
    pub linux_bridge_height: u32,
    pub linux_bridge_pixels: Vec<u32>,
}

impl Window {
    fn new_base(id: usize, title: &str, x: i32, y: i32, width: u32, height: u32) -> Self {
        let buffer_size = (width * height) as usize;
        Self {
            id,
            rect: Rect::new(x, y, width, height),
            title: String::from(title),
            buffer: alloc::vec![0xFFFFFFFF; buffer_size],
            state: WindowState::Normal,
            kind: WindowKind::Terminal,
            controls: WindowControls::new(x, y, width),
            saved_rect: Rect::new(x, y, width, height),

            input_buffer: String::new(),
            output_lines: alloc::vec![],
            cursor_x: 0,
            current_dir_cluster: unsafe { crate::fat32::GLOBAL_FAT.root_cluster },
            current_path: String::from("REDUX/"),

            explorer_items: alloc::vec![],
            explorer_current_cluster: 0,
            explorer_device_index: None,
            explorer_path: String::from("Quick Access"),
            explorer_status: String::new(),
            explorer_preview_lines: alloc::vec![],

            notepad_file_name: String::from("NOTE.TXT"),
            notepad_text: String::new(),
            notepad_status: String::from("Ready."),
            notepad_dir_cluster: unsafe { crate::fat32::GLOBAL_FAT.root_cluster },
            notepad_dir_path: String::from("/"),
            notepad_edit_name: false,

            browser_url: String::from("https://reduxos.org/welcome"),
            browser_status: String::from("Ready"),
            browser_content_lines: alloc::vec![],
            browser_scroll: 0,
            browser_surface_source: String::new(),
            browser_surface_width: 0,
            browser_surface_height: 0,
            browser_surface_pixels: alloc::vec![],

            image_viewer_file_name: String::new(),
            image_viewer_status: String::from("No image loaded."),
            image_viewer_width: 0,
            image_viewer_height: 0,
            image_viewer_pixels: alloc::vec![],

            app_runner_source_file: String::new(),
            app_runner_theme: String::from("light"),
            app_runner_header_text: String::from("App"),
            app_runner_body_text: String::from("No layout loaded."),
            app_runner_button_label: String::from("Run"),
            app_runner_status: String::from("Ready."),
            app_runner_background_color: 0xF4F8FC,
            app_runner_header_color: 0x1F4D78,
            app_runner_body_color: 0x203345,
            app_runner_button_color: 0x2D89D6,
            doom_status: String::from("Listo para iniciar DOOM."),
            linux_bridge_status: String::from("Bridge inactivo."),
            linux_bridge_source: String::from("SDL/X11 subset"),
            linux_bridge_width: 0,
            linux_bridge_height: 0,
            linux_bridge_pixels: alloc::vec![],
        }
    }

    pub fn new(id: usize, title: &str, x: i32, y: i32, width: u32, height: u32) -> Self {
        let mut win = Self::new_base(id, title, x, y, width, height);

        win.output_lines.push(String::from("=== ReduxOS Terminal ==="));
        win.output_lines.push(String::from(""));
        win.output_lines.push(String::from("Available commands:"));
        win.output_lines.push(String::from("  ls        - List files"));
        win.output_lines.push(String::from("  cd <dir>  - Change directory"));
        win.output_lines.push(String::from("  cat <file>- Read file"));
        win.output_lines.push(String::from("  cp <s> <d>- Copy file"));
        win.output_lines.push(String::from("  mv <s> <d>- Move/rename file"));
        win.output_lines.push(String::from("  disks     - List USB/NVMe/HDD devices"));
        win.output_lines.push(String::from("  vols      - List FAT32 volumes"));
        win.output_lines.push(String::from("  mount <n> - Mount FAT32 from 'disks' index"));
        win.output_lines.push(String::from("  unmount   - Unmount active volume"));
        win.output_lines.push(String::from("  cpdev     - Copy file between devices (USB/NVMe/HDD)"));
        win.output_lines.push(String::from("  net       - Show transport/IP/failover status"));
        win.output_lines.push(String::from("  net dhcp  - Request dynamic IP"));
        win.output_lines.push(String::from("  net static - Apply default static IP"));
        win.output_lines.push(String::from("  net mode  - Show current IP mode"));
        win.output_lines.push(String::from("  net https <on|off|status> - HTTPS compatibility"));
        win.output_lines.push(String::from("  net diag  - Dump Intel Ethernet registers"));
        win.output_lines.push(String::from("  wifi      - Show WiFi status"));
        win.output_lines.push(String::from("  fetch     - Download file from network"));
        win.output_lines.push(String::from("  web       - Browser backend (builtin/vaev/webkit/status)"));
        win.output_lines.push(String::from("  web webkit <status|endpoint|ping|open|frame|input> - Host WebKit bridge"));
        win.output_lines.push(String::from("  web vaev status - Embedded Vaev bridge diagnostics"));
        win.output_lines.push(String::from(
            "  web vaev input <click x y|scroll d|key K|text T|back|forward|reload>",
        ));
        win.output_lines.push(String::from("  install [--autoport] - Install package (.RPX/.ZIP/.TAR/.TAR.GZ/.DEB/.EXE-SFX)"));
        win.output_lines.push(String::from("  entry     - Generic installer entry point"));
        win.output_lines.push(String::from("  linux     - Linux ELF64 phase1 + phase2 dynamic (+ launch experimental)"));
        win.output_lines.push(String::from("  ruby      - Run Ruby subset runtime"));
        win.output_lines.push(String::from("  runapp    - Open .RML app layout in App Runner"));
        win.output_lines.push(String::from("  doom      - Launch external UEFI Doom image"));
        win.output_lines.push(String::from("  shell     - Launch external UEFI Shell image"));
        win.output_lines.push(String::from("  clear     - Clear screen"));
        win.output_lines.push(String::from("  help      - Show this help"));
        win.output_lines.push(String::from(""));

        win.render();
        win
    }

    pub fn new_explorer(id: usize, title: &str, x: i32, y: i32, width: u32, height: u32) -> Self {
        let mut win = Self::new_base(id, title, x, y, width, height);
        win.kind = WindowKind::Explorer;
        win.set_explorer_home();
        win
    }

    pub fn new_notepad(id: usize, title: &str, x: i32, y: i32, width: u32, height: u32) -> Self {
        let mut win = Self::new_base(id, title, x, y, width, height);
        win.kind = WindowKind::Notepad;
        win.notepad_status = String::from("Use NEW/SAVE/DELETE and edit text area.");
        win.render();
        win
    }

    pub fn new_browser(id: usize, title: &str, x: i32, y: i32, width: u32, height: u32) -> Self {
        let mut win = Self::new_base(id, title, x, y, width, height);
        win.kind = WindowKind::Browser;
        win.browser_url = String::from("redux://welcome");
        
        win.browser_content_lines.push(String::from("Welcome to ReduxOS Web Browser!"));
        win.browser_content_lines.push(String::from(""));
        win.browser_content_lines.push(String::from("Features:"));
        win.browser_content_lines.push(String::from("- Render grafico local (DOM/layout/raster builtin)"));
        win.browser_content_lines.push(String::from("- HTML/CSS/JS en modo subset (sin host bridge obligatorio)"));
        win.browser_content_lines.push(String::from("- Tip: usa `web native on` para forzar superficie interna"));
        win.browser_content_lines.push(String::from(""));
        win.browser_content_lines.push(String::from("Try visiting: https://example.com"));
        win.browser_content_lines.push(String::from("Also available: redux://about"));

        win.render();
        win
    }

    pub fn new_image_viewer(
        id: usize,
        title: &str,
        x: i32,
        y: i32,
        width: u32,
        height: u32,
    ) -> Self {
        let mut win = Self::new_base(id, title, x, y, width, height);
        win.kind = WindowKind::ImageViewer;
        win.image_viewer_status = String::from("Open a PNG from Explorer.");
        win.render();
        win
    }

    pub fn new_settings(id: usize, title: &str, x: i32, y: i32, width: u32, height: u32) -> Self {
        let mut win = Self::new_base(id, title, x, y, width, height);
        win.kind = WindowKind::Settings;
        win.render();
        win
    }

    pub fn new_app_runner(
        id: usize,
        title: &str,
        x: i32,
        y: i32,
        width: u32,
        height: u32,
    ) -> Self {
        let mut win = Self::new_base(id, title, x, y, width, height);
        win.kind = WindowKind::AppRunner;
        win.app_runner_status = String::from("No .RML layout loaded.");
        win.render();
        win
    }

    pub fn new_doom_launcher(
        id: usize,
        title: &str,
        x: i32,
        y: i32,
        width: u32,
        height: u32,
    ) -> Self {
        let mut win = Self::new_base(id, title, x, y, width, height);
        win.kind = WindowKind::DoomLauncher;
        win.doom_status = String::from("Listo para iniciar DOOM.");
        win.render();
        win
    }

    pub fn new_linux_bridge(
        id: usize,
        title: &str,
        x: i32,
        y: i32,
        width: u32,
        height: u32,
    ) -> Self {
        let mut win = Self::new_base(id, title, x, y, width, height);
        win.kind = WindowKind::LinuxBridge;
        win.linux_bridge_status = String::from("Esperando frames Linux...");
        win.linux_bridge_source = String::from("SDL/X11 subset");
        win.render();
        win
    }

    fn content_height(&self) -> i32 {
        self.rect.height as i32 - TITLE_BAR_H
    }

    fn explorer_cols(&self) -> usize {
        let usable_w = (self.rect.width as i32 - EXPLORER_MARGIN_X * 2).max(EXPLORER_CELL_W);
        let cols = (usable_w + EXPLORER_GAP_X) / (EXPLORER_CELL_W + EXPLORER_GAP_X);
        cols.max(1) as usize
    }

    fn explorer_icon_rect(&self, index: usize) -> Option<Rect> {
        let cols = self.explorer_cols();
        let col = index % cols;
        let row = index / cols;

        let x = EXPLORER_MARGIN_X + (col as i32) * (EXPLORER_CELL_W + EXPLORER_GAP_X);
        let y = EXPLORER_MARGIN_Y + (row as i32) * (EXPLORER_CELL_H + EXPLORER_GAP_Y);
        let max_y = self.content_height() - EXPLORER_STATUS_H;

        if max_y <= EXPLORER_MARGIN_Y || y + EXPLORER_CELL_H > max_y {
            return None;
        }

        Some(Rect::new(x, y, EXPLORER_CELL_W as u32, EXPLORER_CELL_H as u32))
    }

    fn notepad_button_rect(&self, index: usize) -> Rect {
        let x = 10 + (index as i32 * 74);
        Rect::new(x, 7, 68, 20)
    }

    fn notepad_filename_rect(&self) -> Rect {
        let raw_x = (self.rect.width as i32 - 360).max(10);
        let x = raw_x.min((self.rect.width as i32 - 90).max(10));
        let width = (self.rect.width as i32 - x - 10).max(80) as u32;
        Rect::new(x, 7, width, 20)
    }

    fn notepad_editor_rect(&self) -> Rect {
        let y = NOTEPAD_TOP_H + 6;
        let h = (self.content_height() - y - NOTEPAD_STATUS_H - 6).max(24) as u32;
        Rect::new(8, y, self.rect.width.saturating_sub(16), h)
    }

    fn notepad_status_rect(&self) -> Rect {
        let y = (self.content_height() - NOTEPAD_STATUS_H).max(0);
        Rect::new(0, y, self.rect.width, NOTEPAD_STATUS_H as u32)
    }

    fn browser_url_rect(&self) -> Rect {
        let x = 70; // Back/Fwd buttons space
        let width = self.rect.width.saturating_sub(x as u32 + 140); // Go + scroll controls
        Rect::new(x, 10, width, 24)
    }

    fn browser_go_rect(&self) -> Rect {
        let url_rect = self.browser_url_rect();
        let x = url_rect.x + url_rect.width as i32 + 10;
        Rect::new(x, 10, 52, 24)
    }

    fn browser_scroll_up_rect(&self) -> Rect {
        let go = self.browser_go_rect();
        let x = go.x + go.width as i32 + 8;
        Rect::new(x, 10, 20, 11)
    }

    fn browser_scroll_down_rect(&self) -> Rect {
        let up = self.browser_scroll_up_rect();
        Rect::new(up.x, up.y + 13, up.width, 11)
    }

    fn browser_viewport_rect(&self) -> Rect {
        let y = BROWSER_TOP_H;
        let h = (self.content_height() - y - BROWSER_STATUS_H).max(0) as u32;
        Rect::new(0, y, self.rect.width, h)
    }

    fn image_viewer_canvas_rect(&self) -> Rect {
        let y = IMAGE_VIEWER_TOP_H;
        let h = (self.content_height() - y - IMAGE_VIEWER_STATUS_H).max(0) as u32;
        Rect::new(0, y, self.rect.width, h)
    }

    fn app_runner_canvas_rect(&self) -> Rect {
        let y = APP_RUNNER_TOP_H;
        let h = (self.content_height() - y - APP_RUNNER_STATUS_H).max(0) as u32;
        Rect::new(0, y, self.rect.width, h)
    }

    fn doom_launcher_canvas_rect(&self) -> Rect {
        let y = DOOM_LAUNCHER_TOP_H;
        let h = (self.content_height() - y - DOOM_LAUNCHER_STATUS_H).max(0) as u32;
        Rect::new(0, y, self.rect.width, h)
    }

    fn doom_launch_button_rect(&self) -> Rect {
        let view = self.doom_launcher_canvas_rect();
        let btn_w = 180u32.min(view.width.saturating_sub(24).max(120));
        let btn_h = 34u32;
        let x = view.x + ((view.width as i32 - btn_w as i32) / 2).max(0);
        let y = view.y + 34;
        Rect::new(x, y, btn_w, btn_h)
    }

    fn doom_status_rect(&self) -> Rect {
        let y = (self.content_height() - DOOM_LAUNCHER_STATUS_H).max(0);
        Rect::new(0, y, self.rect.width, DOOM_LAUNCHER_STATUS_H as u32)
    }

    fn linux_bridge_canvas_rect(&self) -> Rect {
        let y = LINUX_BRIDGE_TOP_H;
        let h = (self.content_height() - y - LINUX_BRIDGE_STATUS_H).max(0) as u32;
        Rect::new(0, y, self.rect.width, h)
    }

    fn linux_bridge_status_rect(&self) -> Rect {
        let y = (self.content_height() - LINUX_BRIDGE_STATUS_H).max(0);
        Rect::new(0, y, self.rect.width, LINUX_BRIDGE_STATUS_H as u32)
    }

    fn browser_text_max_cols(&self) -> usize {
        let view = self.browser_viewport_rect();
        let usable = (view.width as i32 - 28).max(6);
        (usable / 6).max(1) as usize
    }

    fn browser_visible_rows(&self) -> usize {
        let view = self.browser_viewport_rect();
        ((view.height as i32 - 8) / 10).max(1) as usize
    }

    fn browser_flat_lines(&self) -> Vec<String> {
        let max_cols = self.browser_text_max_cols();
        let mut flat: Vec<String> = Vec::new();
        for line in self.browser_content_lines.iter() {
            if line.trim().is_empty() {
                if !flat
                    .last()
                    .map(|s: &String| s.is_empty())
                    .unwrap_or(false)
                {
                    flat.push(String::new());
                }
                continue;
            }

            let wrapped = Self::wrap_text_lines(line.as_str(), max_cols, 256);
            if wrapped.is_empty() {
                if !flat
                    .last()
                    .map(|s: &String| s.is_empty())
                    .unwrap_or(false)
                {
                    flat.push(String::new());
                }
                continue;
            }

            for w in wrapped {
                flat.push(w);
            }
        }

        if flat.is_empty() {
            flat.push(String::from("(sin contenido)"));
        }

        flat
    }

    fn browser_max_scroll(&self) -> usize {
        let flat = self.browser_flat_lines();
        flat.len().saturating_sub(self.browser_visible_rows())
    }

    fn normalize_link_candidate(token: &str) -> Option<String> {
        let clean = token.trim_matches(|c: char| {
            matches!(c, '<' | '>' | '"' | '\'' | '(' | ')' | '[' | ']' | '{' | '}' | ',' | ';')
        });
        if clean.is_empty() {
            return None;
        }

        let lower = clean
            .bytes()
            .map(|b| (b as char).to_ascii_lowercase())
            .collect::<String>();

        if lower.starts_with("http://") || lower.starts_with("https://") || lower.starts_with("redux://") {
            return Some(String::from(clean));
        }
        None
    }

    fn extract_first_url_from_text(text: &str) -> Option<String> {
        if let Some(start) = text.find('<') {
            if let Some(end_rel) = text[start + 1..].find('>') {
                let end = start + 1 + end_rel;
                if end > start + 1 {
                    let inside = &text[start + 1..end];
                    if let Some(url) = Self::normalize_link_candidate(inside) {
                        return Some(url);
                    }
                }
            }
        }

        for token in text.split_whitespace() {
            if let Some(url) = Self::normalize_link_candidate(token) {
                return Some(url);
            }
        }
        None
    }

    fn trim_label(text: &str, max_chars: usize) -> String {
        if text.len() <= max_chars {
            return String::from(text);
        }
        let mut out = String::new();
        for b in text.bytes().take(max_chars.saturating_sub(3)) {
            out.push(b as char);
        }
        out.push_str("...");
        out
    }

    fn draw_border(&mut self, rect: Rect, color: Color) {
        if rect.width == 0 || rect.height == 0 {
            return;
        }

        self.fill_rect(Rect::new(rect.x, rect.y, rect.width, 1), color);
        self.fill_rect(
            Rect::new(rect.x, rect.y + rect.height as i32 - 1, rect.width, 1),
            color,
        );
        self.fill_rect(Rect::new(rect.x, rect.y, 1, rect.height), color);
        self.fill_rect(
            Rect::new(rect.x + rect.width as i32 - 1, rect.y, 1, rect.height),
            color,
        );
    }

    fn draw_explorer_icon(&mut self, rect: Rect, kind: ExplorerItemKind) {
        match kind {
            ExplorerItemKind::ShortcutUsb | ExplorerItemKind::ShortcutVolume => {
                self.fill_rect(
                    Rect::new(rect.x + 10, rect.y + 22, rect.width - 20, rect.height - 26),
                    Color(0x7E8C99),
                );
                self.fill_rect(
                    Rect::new(rect.x + 14, rect.y + 26, rect.width - 28, rect.height - 34),
                    Color(0xC3CCD4),
                );
                self.fill_rect(
                    Rect::new(rect.x + rect.width as i32 - 18, rect.y + rect.height as i32 - 14, 4, 4),
                    Color(0x4ACA6D),
                );
            }
            ExplorerItemKind::File => {
                self.fill_rect(
                    Rect::new(rect.x + 14, rect.y + 8, rect.width - 28, rect.height - 16),
                    Color(0xFFFFFF),
                );
                self.draw_border(
                    Rect::new(rect.x + 14, rect.y + 8, rect.width - 28, rect.height - 16),
                    Color(0xA5B2BF),
                );
                self.fill_rect(
                    Rect::new(rect.x + rect.width as i32 - 24, rect.y + 8, 10, 10),
                    Color(0xE1E7EE),
                );
            }
            ExplorerItemKind::Home => {
                self.fill_rect(
                    Rect::new(rect.x + 16, rect.y + 22, rect.width - 32, rect.height - 24),
                    Color(0x8DB7E2),
                );
                self.fill_rect(
                    Rect::new(rect.x + 26, rect.y + 32, rect.width - 52, rect.height - 36),
                    Color(0xDCEEFF),
                );
                self.fill_rect(Rect::new(rect.x + 34, rect.y + 40, 12, 14), Color(0x6F95B7));
            }
            ExplorerItemKind::Up => {
                self.fill_rect(
                    Rect::new(rect.x + 10, rect.y + 18, rect.width - 20, rect.height - 22),
                    Color(0xD2DCE7),
                );
                let mid = rect.x + rect.width as i32 / 2;
                self.fill_rect(Rect::new(mid - 2, rect.y + 16, 4, 30), Color(0x2D4A63));
                self.fill_rect(Rect::new(mid - 8, rect.y + 22, 16, 4), Color(0x2D4A63));
            }
            ExplorerItemKind::ShortcutDesktop
            | ExplorerItemKind::ShortcutDownloads
            | ExplorerItemKind::ShortcutDocuments
            | ExplorerItemKind::ShortcutImages
            | ExplorerItemKind::ShortcutVideos
            | ExplorerItemKind::Directory => {
                self.fill_rect(
                    Rect::new(rect.x + 10, rect.y + 20, rect.width - 20, rect.height - 24),
                    Color(0xF0C86E),
                );
                self.fill_rect(Rect::new(rect.x + 16, rect.y + 12, 24, 10), Color(0xF7D88E));
                self.draw_border(
                    Rect::new(rect.x + 10, rect.y + 20, rect.width - 20, rect.height - 24),
                    Color(0xCFA24A),
                );
            }
        }
    }

    fn wrap_text_lines(text: &str, max_cols: usize, max_lines: usize) -> Vec<String> {
        let mut out = Vec::new();
        let mut line = String::new();

        for ch in text.chars() {
            if ch == '\r' {
                continue;
            }

            if ch == '\n' {
                out.push(line.clone());
                line.clear();
                if out.len() >= max_lines {
                    return out;
                }
                continue;
            }

            line.push(ch);
            if line.len() >= max_cols {
                out.push(line.clone());
                line.clear();
                if out.len() >= max_lines {
                    return out;
                }
            }
        }

        if out.len() < max_lines {
            out.push(line);
        }

        if out.is_empty() {
            out.push(String::new());
        }

        out
    }

    pub fn draw_pixel(&mut self, x: u32, y: u32, color: Color) {
        if x < self.rect.width && y < self.rect.height {
            let idx = (y * self.rect.width + x) as usize;
            self.buffer[idx] = color.0;
        }
    }

    pub fn fill_rect(&mut self, rect: Rect, color: Color) {
        let start_x = rect.x.max(0) as u32;
        let start_y = rect.y.max(0) as u32;
        let end_x = (rect.x + rect.width as i32).min(self.rect.width as i32) as u32;
        let end_y = (rect.y + rect.height as i32).min(self.rect.height as i32) as u32;

        for dy in start_y..end_y {
            for dx in start_x..end_x {
                self.draw_pixel(dx, dy, color);
            }
        }
    }

    pub fn draw_char(&mut self, x: u32, y: u32, ch: char, color: Color) {
        let glyph = crate::font::glyph_5x7(ch);
        for (row, bits) in glyph.iter().enumerate() {
            for col in 0..5 {
                let mask = 1 << (4 - col);
                if (bits & mask) != 0 {
                    self.draw_pixel(x + col as u32, y + row as u32, color);
                }
            }
        }
    }

    pub fn draw_text(&mut self, x: u32, y: u32, text: &[u8], color: Color) {
        let mut cx = x;
        let mut cy = y;
        for &b in text {
            if b == b'\n' {
                cx = x;
                cy += 8;
                continue;
            }
            let ch = if b.is_ascii() { b as char } else { '?' };
            self.draw_char(cx, cy, ch, color);
            cx += 6;
        }
    }

    pub fn minimize(&mut self) {
        self.state = WindowState::Minimized;
    }

    pub fn maximize(&mut self, screen_width: usize, screen_height: usize) {
        if self.state == WindowState::Maximized {
            self.rect = self.saved_rect;
            self.resize_buffer(self.rect.width, self.rect.height);
            self.state = WindowState::Normal;
        } else {
            self.saved_rect = self.rect;
            self.rect = Rect::new(0, 0, screen_width as u32, (screen_height - 40) as u32);
            self.resize_buffer(self.rect.width, self.rect.height);
            self.state = WindowState::Maximized;
        }
        self.controls = WindowControls::new(self.rect.x, self.rect.y, self.rect.width);
        self.render();
    }

    pub fn resize_buffer(&mut self, width: u32, height: u32) {
        let size = (width * height) as usize;
        self.buffer.resize(size, 0xFFFFFFFF);
    }

    pub fn restore(&mut self) {
        if self.state == WindowState::Minimized {
            self.state = WindowState::Normal;
        } else if self.state == WindowState::Maximized {
            self.rect = self.saved_rect;
            self.resize_buffer(self.rect.width, self.rect.height);
            self.controls = WindowControls::new(self.rect.x, self.rect.y, self.rect.width);
            self.state = WindowState::Normal;
            self.render();
        }
    }

    pub fn close(&mut self) {
        self.state = WindowState::Closed;
    }

    pub fn is_terminal(&self) -> bool {
        self.kind == WindowKind::Terminal
    }

    pub fn is_explorer(&self) -> bool {
        self.kind == WindowKind::Explorer
    }

    pub fn is_notepad(&self) -> bool {
        self.kind == WindowKind::Notepad
    }

    pub fn is_browser(&self) -> bool {
        self.kind == WindowKind::Browser
    }

    pub fn is_image_viewer(&self) -> bool {
        self.kind == WindowKind::ImageViewer
    }

    pub fn is_app_runner(&self) -> bool {
        self.kind == WindowKind::AppRunner
    }

    pub fn is_doom_launcher(&self) -> bool {
        self.kind == WindowKind::DoomLauncher
    }

    pub fn is_linux_bridge(&self) -> bool {
        self.kind == WindowKind::LinuxBridge
    }

    pub fn is_settings(&self) -> bool {
        self.kind == WindowKind::Settings
    }

    pub fn title_bar_contains(&self, x: i32, y: i32) -> bool {
        let bar = Rect::new(self.rect.x, self.rect.y, self.rect.width, TITLE_BAR_H as u32);
        bar.contains(crate::gui::Point { x, y })
    }

    pub fn resize_grip_contains(&self, x: i32, y: i32) -> bool {
        let grip = WINDOW_RESIZE_GRIP;
        let gx = (self.rect.x + self.rect.width as i32 - grip).max(self.rect.x);
        let gy = (self.rect.y + self.rect.height as i32 - grip).max(self.rect.y);
        Rect::new(gx, gy, grip as u32, grip as u32).contains(crate::gui::Point { x, y })
    }

    pub fn min_dimensions(&self) -> (u32, u32) {
        match self.kind {
            WindowKind::Terminal => (420, 260),
            WindowKind::Explorer => (620, 380),
            WindowKind::Notepad => (520, 320),
            WindowKind::Browser => (600, 400),
            WindowKind::ImageViewer => (520, 360),
            WindowKind::AppRunner => (560, 380),
            WindowKind::DoomLauncher => (520, 340),
            WindowKind::LinuxBridge => (560, 380),
            WindowKind::Settings => (480, 360),
        }
    }

    pub fn move_to(&mut self, x: i32, y: i32) {
        self.rect.x = x;
        self.rect.y = y;
        self.controls = WindowControls::new(self.rect.x, self.rect.y, self.rect.width);
    }

    pub fn resize_to(&mut self, width: u32, height: u32) {
        if self.rect.width == width && self.rect.height == height {
            return;
        }

        self.rect.width = width;
        self.rect.height = height;
        self.resize_buffer(width, height);
        self.controls = WindowControls::new(self.rect.x, self.rect.y, self.rect.width);
        self.render();
    }
    pub fn hit_test_controls(&self, x: i32, y: i32) -> Option<&str> {
        use crate::gui::Point;
        let p = Point { x, y };

        if self.controls.close_btn.contains(p) {
            return Some("close");
        }
        if self.controls.maximize_btn.contains(p) {
            return Some("maximize");
        }
        if self.controls.minimize_btn.contains(p) {
            return Some("minimize");
        }
        None
    }

    pub fn render(&mut self) {
        match self.kind {
            WindowKind::Terminal => self.render_terminal(),
            WindowKind::Explorer => self.render_explorer(),
            WindowKind::Notepad => self.render_notepad(),
            WindowKind::Browser => self.render_browser(),
            WindowKind::ImageViewer => self.render_image_viewer(),
            WindowKind::AppRunner => self.render_app_runner(),
            WindowKind::DoomLauncher => self.render_doom_launcher(),
            WindowKind::LinuxBridge => self.render_linux_bridge(),
            WindowKind::Settings => self.render_settings(),
        }
    }

    pub fn render_terminal(&mut self) {
        if self.kind != WindowKind::Terminal {
            return;
        }

        self.buffer.fill(0xFFFFFFFF);

        let lines = self.output_lines.clone();
        let mut y = 10;
        for line in &lines {
            self.draw_text(10, y as u32, line.as_bytes(), Color(0x000000));
            y += 12;
        }

        let prompt_path = self.current_path.clone();
        let prompt_tail = "> ";
        let input_clone = self.input_buffer.clone();

        self.draw_text(10, y as u32, prompt_path.as_bytes(), Color(0x0066CC));
        let prompt_w = prompt_path.len() * 6;
        self.draw_text((10 + prompt_w) as u32, y as u32, prompt_tail.as_bytes(), Color(0x0066CC));

        let total_prompt_w = prompt_w + (prompt_tail.len() * 6);
        self.draw_text(
            (10 + total_prompt_w) as u32,
            y as u32,
            input_clone.as_bytes(),
            Color(0x000000),
        );

        let cursor_x = 10 + total_prompt_w + (input_clone.len() * 6);
        self.draw_text(cursor_x as u32, y as u32, b"_", Color(0x000000));
    }

    pub fn render_explorer(&mut self) {
        if self.kind != WindowKind::Explorer {
            return;
        }

        let content_h = self.content_height();
        if content_h <= 0 {
            return;
        }

        self.fill_rect(Rect::new(0, 0, self.rect.width, content_h as u32), Color(0xEAF1F8));
        self.fill_rect(Rect::new(0, 0, self.rect.width, EXPLORER_TOP_H as u32), Color(0xD3E1EF));

        self.draw_text(10, 8, b"FILE EXPLORER", Color(0x1D354A));
        let path_text = Self::trim_label(self.explorer_path.as_str(), 70);
        self.draw_text(10, 18, path_text.as_bytes(), Color(0x2E668E));

        let items = self.explorer_items.clone();
        for (idx, item) in items.iter().enumerate() {
            let Some(slot) = self.explorer_icon_rect(idx) else {
                continue;
            };

            self.fill_rect(slot, Color(0xF7FAFF));
            self.draw_border(slot, Color(0xB8C8D8));

            let icon_rect = Rect::new(slot.x + 20, slot.y + 4, 66, 62);
            self.draw_explorer_icon(icon_rect, item.kind);

            let label = Self::trim_label(item.label.as_str(), 14);
            let text_w = (label.len() as i32) * 6;
            let text_x = (slot.x + ((slot.width as i32 - text_w) / 2)).max(2);
            self.draw_text(text_x as u32, (slot.y + 74) as u32, label.as_bytes(), Color(0x1D2A36));
        }

        let status_y = (content_h - EXPLORER_STATUS_H).max(0);
        self.fill_rect(
            Rect::new(0, status_y, self.rect.width, EXPLORER_STATUS_H as u32),
            Color(0xDCE6F0),
        );
        self.fill_rect(Rect::new(0, status_y, self.rect.width, 1), Color(0xA8BCCC));

        let status_text = Self::trim_label(self.explorer_status.as_str(), 72);
        self.draw_text(10, (status_y + 8) as u32, status_text.as_bytes(), Color(0x233A4F));

        let preview = self.explorer_preview_lines.clone();
        let mut py = status_y + 20;
        for line in preview.iter().take(4) {
            let trimmed = Self::trim_label(line.as_str(), 72);
            self.draw_text(10, py as u32, trimmed.as_bytes(), Color(0x394C5D));
            py += 9;
        }
    }

    pub fn render_notepad(&mut self) {
        if self.kind != WindowKind::Notepad {
            return;
        }

        let content_h = self.content_height();
        if content_h <= 0 {
            return;
        }

        self.fill_rect(Rect::new(0, 0, self.rect.width, content_h as u32), Color(0xF8FBFF));
        self.fill_rect(Rect::new(0, 0, self.rect.width, NOTEPAD_TOP_H as u32), Color(0xD7E6F8));
        self.fill_rect(Rect::new(0, NOTEPAD_TOP_H, self.rect.width, 1), Color(0xA6BED6));

        let button_labels = ["NEW", "SAVE", "DELETE"];
        let button_colors = [0x4A8BC2, 0x3CA66B, 0xC45A57];
        for i in 0..3 {
            let rect = self.notepad_button_rect(i);
            self.fill_rect(rect, Color(button_colors[i]));
            self.draw_border(rect, Color(0x23374D));
            self.draw_text(
                (rect.x + 14) as u32,
                (rect.y + 7) as u32,
                button_labels[i].as_bytes(),
                Color(0xFFFFFF),
            );
        }

        let name_rect = self.notepad_filename_rect();
        self.fill_rect(name_rect, Color(0xFFFFFF));
        self.draw_border(
            name_rect,
            if self.notepad_edit_name {
                Color(0x2A6FAE)
            } else {
                Color(0x8FA8C4)
            },
        );

        let file_text = alloc::format!("File: {}", self.notepad_file_name);
        let file_text_trim = Self::trim_label(file_text.as_str(), ((name_rect.width as usize) / 6).saturating_sub(2));
        self.draw_text(
            (name_rect.x + 4) as u32,
            (name_rect.y + 7) as u32,
            file_text_trim.as_bytes(),
            Color(0x1E3C5A),
        );

        let editor = self.notepad_editor_rect();
        self.fill_rect(editor, Color(0xFFFFFF));
        self.draw_border(editor, Color(0xAFC0D3));

        let max_cols = ((editor.width as i32 - 8) / 6).max(1) as usize;
        let max_lines = ((editor.height as i32 - 8) / 9).max(1) as usize;
        let lines = Self::wrap_text_lines(self.notepad_text.as_str(), max_cols, max_lines);

        for (i, line) in lines.iter().enumerate() {
            self.draw_text(
                (editor.x + 4) as u32,
                (editor.y + 4 + (i as i32 * 9)) as u32,
                line.as_bytes(),
                Color(0x182736),
            );
        }

        if self.notepad_edit_name {
            let caret_x = (name_rect.x + 4 + file_text_trim.len() as i32 * 6)
                .min(name_rect.x + name_rect.width as i32 - 8)
                .max(name_rect.x + 4);
            self.draw_text(caret_x as u32, (name_rect.y + 7) as u32, b"_", Color(0x1E3C5A));
        } else {
            let line_idx = lines.len().saturating_sub(1);
            let col = lines.get(line_idx).map(|s| s.len()).unwrap_or(0);
            let caret_x = (editor.x + 4 + col as i32 * 6).min(editor.x + editor.width as i32 - 8);
            let caret_y = (editor.y + 4 + line_idx as i32 * 9).min(editor.y + editor.height as i32 - 10);
            self.draw_text(caret_x as u32, caret_y as u32, b"_", Color(0x182736));
        }

        let status_rect = self.notepad_status_rect();
        self.fill_rect(status_rect, Color(0xE6EEF8));
        self.fill_rect(
            Rect::new(status_rect.x, status_rect.y, status_rect.width, 1),
            Color(0xA6BED6),
        );

        let path_text = alloc::format!("Path: {}", self.notepad_dir_path);
        let path_trim = Self::trim_label(path_text.as_str(), 46);
        self.draw_text(
            8,
            (status_rect.y + 8) as u32,
            path_trim.as_bytes(),
            Color(0x2E4B66),
        );

        let status_trim = Self::trim_label(self.notepad_status.as_str(), 72);
        self.draw_text(
            8,
            (status_rect.y + 17) as u32,
            status_trim.as_bytes(),
            Color(0x2E4B66),
        );
    }

    pub fn render_browser(&mut self) {
        if self.kind != WindowKind::Browser {
            return;
        }

        let content_h = self.content_height();
        if content_h <= 0 {
            return;
        }

        // Background
        self.fill_rect(Rect::new(0, 0, self.rect.width, content_h as u32), Color(0xF2F2F2));

        // Top Bar
        self.fill_rect(Rect::new(0, 0, self.rect.width, BROWSER_TOP_H as u32), Color(0xDDDDDD));
        self.fill_rect(Rect::new(0, BROWSER_TOP_H - 1, self.rect.width, 1), Color(0xAAAAAA));

        // Nav Buttons (Visual only)
        self.fill_rect(Rect::new(10, 10, 24, 24), Color(0xCCCCCC)); // Back
        self.draw_text(18, 18, b"<", Color(0x555555));
        self.fill_rect(Rect::new(40, 10, 24, 24), Color(0xCCCCCC)); // Fwd
        self.draw_text(48, 18, b">", Color(0x555555));

        // URL Bar
        let url_rect = self.browser_url_rect();
        self.fill_rect(url_rect, Color(0xFFFFFF));
        self.draw_border(url_rect, Color(0x999999));
        
        let url_trim = Self::trim_label(self.browser_url.as_str(), ((url_rect.width as usize) / 6).saturating_sub(2));
        self.draw_text((url_rect.x + 6) as u32, (url_rect.y + 8) as u32, url_trim.as_bytes(), Color(0x333333));

        // Go Button
        let go_rect = self.browser_go_rect();
        self.fill_rect(go_rect, Color(0x4A90E2));
        self.draw_border(go_rect, Color(0x357ABD));
        self.draw_text((go_rect.x + 17) as u32, (go_rect.y + 8) as u32, b"GO", Color(0xFFFFFF));

        // Scroll Controls
        let up_rect = self.browser_scroll_up_rect();
        let down_rect = self.browser_scroll_down_rect();
        self.fill_rect(up_rect, Color(0xC8D4E2));
        self.fill_rect(down_rect, Color(0xC8D4E2));
        self.draw_border(up_rect, Color(0x7C8FA6));
        self.draw_border(down_rect, Color(0x7C8FA6));
        self.draw_text((up_rect.x + 7) as u32, (up_rect.y + 2) as u32, b"^", Color(0x1E2E40));
        self.draw_text((down_rect.x + 7) as u32, (down_rect.y + 2) as u32, b"v", Color(0x1E2E40));

        // Viewport
        let view_rect = self.browser_viewport_rect();
        self.fill_rect(view_rect, Color(0xFFFFFF));
        let surf_w = self.browser_surface_width as usize;
        let surf_h = self.browser_surface_height as usize;
        let has_surface = surf_w > 0
            && surf_h > 0
            && self.browser_surface_pixels.len() >= surf_w.saturating_mul(surf_h);

        if has_surface {
            let avail_w = (view_rect.width as i32 - 8).max(1) as usize;
            let avail_h = (view_rect.height as i32 - 8).max(1) as usize;

            let mut draw_w = avail_w;
            let mut draw_h = (surf_h.saturating_mul(draw_w)).max(1) / surf_w.max(1);
            if draw_h > avail_h {
                draw_h = avail_h;
                draw_w = (surf_w.saturating_mul(draw_h)).max(1) / surf_h.max(1);
            }
            draw_w = draw_w.max(1).min(avail_w);
            draw_h = draw_h.max(1).min(avail_h);

            let start_x = view_rect.x + ((view_rect.width as i32 - draw_w as i32) / 2);
            let start_y = view_rect.y + ((view_rect.height as i32 - draw_h as i32) / 2);

            for dy in 0..draw_h {
                let sy = dy.saturating_mul(surf_h) / draw_h.max(1);
                for dx in 0..draw_w {
                    let sx = dx.saturating_mul(surf_w) / draw_w.max(1);
                    let src_idx = sy.saturating_mul(surf_w).saturating_add(sx);
                    if src_idx >= self.browser_surface_pixels.len() {
                        continue;
                    }
                    self.draw_pixel(
                        (start_x + dx as i32).max(0) as u32,
                        (start_y + dy as i32).max(0) as u32,
                        Color(self.browser_surface_pixels[src_idx]),
                    );
                }
            }

            self.draw_border(view_rect, Color(0xA7BACD));
            let src = if self.browser_surface_source.trim().is_empty() {
                String::from("servo")
            } else {
                self.browser_surface_source.clone()
            };
            let src_trim = Self::trim_label(src.as_str(), 48);
            self.draw_text(
                (view_rect.x + 8).max(0) as u32,
                (view_rect.y + 4).max(0) as u32,
                alloc::format!("Surface: {}", src_trim).as_bytes(),
                Color(0x2A3B4F),
            );
        } else {
            let flat = self.browser_flat_lines();
            let visible_rows = self.browser_visible_rows();
            let max_scroll = flat.len().saturating_sub(visible_rows);
            if self.browser_scroll > max_scroll {
                self.browser_scroll = max_scroll;
            }

            let mut y_offset = 4;
            for line in flat
                .iter()
                .skip(self.browser_scroll)
                .take(visible_rows)
            {
                if y_offset + 9 > view_rect.height as i32 {
                    break;
                }
                self.draw_text(
                    (view_rect.x + 8) as u32,
                    (view_rect.y + y_offset) as u32,
                    line.as_bytes(),
                    Color(0x000000),
                );
                y_offset += 10;
            }

            // Vertical scrollbar
            if flat.len() > visible_rows {
                let track = Rect::new(
                    view_rect.x + view_rect.width as i32 - 8,
                    view_rect.y + 1,
                    7,
                    view_rect.height.saturating_sub(2),
                );
                self.fill_rect(track, Color(0xE8EEF5));

                let track_h = track.height.max(1) as usize;
                let thumb_h = ((track_h * visible_rows) / flat.len()).max(12).min(track_h);
                let max_thumb_y = track_h.saturating_sub(thumb_h);
                let thumb_off = if max_scroll == 0 {
                    0
                } else {
                    (max_thumb_y * self.browser_scroll) / max_scroll
                } as i32;
                let thumb = Rect::new(track.x + 1, track.y + thumb_off, 5, thumb_h as u32);
                self.fill_rect(thumb, Color(0x95A8BE));
            }
        }

        // Status Bar
        let status_y = (content_h - BROWSER_STATUS_H).max(0);
        self.fill_rect(Rect::new(0, status_y, self.rect.width, BROWSER_STATUS_H as u32), Color(0xEEEEEE));
        self.fill_rect(Rect::new(0, status_y, self.rect.width, 1), Color(0xCCCCCC));

        let status_trim = Self::trim_label(self.browser_status.as_str(), 80);
        self.draw_text(6, (status_y + 8) as u32, status_trim.as_bytes(), Color(0x666666));
    }

    pub fn render_image_viewer(&mut self) {
        if self.kind != WindowKind::ImageViewer {
            return;
        }

        let content_h = self.content_height();
        if content_h <= 0 {
            return;
        }

        self.fill_rect(Rect::new(0, 0, self.rect.width, content_h as u32), Color(0xEAF1F8));
        self.fill_rect(
            Rect::new(0, 0, self.rect.width, IMAGE_VIEWER_TOP_H as u32),
            Color(0xD5E3F1),
        );
        self.fill_rect(Rect::new(0, IMAGE_VIEWER_TOP_H - 1, self.rect.width, 1), Color(0xA3B8CC));

        self.draw_text(10, 10, b"IMAGE VIEWER", Color(0x1F3952));
        let name_trim = Self::trim_label(self.image_viewer_file_name.as_str(), 62);
        self.draw_text(10, 22, name_trim.as_bytes(), Color(0x2F5B81));
        let info = if self.image_viewer_width == 0 || self.image_viewer_height == 0 {
            String::from("No image loaded")
        } else {
            alloc::format!(
                "{}x{} px",
                self.image_viewer_width, self.image_viewer_height
            )
        };
        self.draw_text(10, 34, info.as_bytes(), Color(0x2F5B81));

        let view = self.image_viewer_canvas_rect();
        self.fill_rect(view, Color(0xFFFFFF));
        self.draw_border(view, Color(0xA7BACD));

        let img_w = self.image_viewer_width as usize;
        let img_h = self.image_viewer_height as usize;
        if img_w > 0 && img_h > 0 && self.image_viewer_pixels.len() >= img_w.saturating_mul(img_h) {
            let avail_w = (view.width as i32 - 16).max(1) as usize;
            let avail_h = (view.height as i32 - 16).max(1) as usize;

            let mut draw_w = avail_w;
            let mut draw_h = (img_h.saturating_mul(draw_w)).max(1) / img_w.max(1);
            if draw_h > avail_h {
                draw_h = avail_h;
                draw_w = (img_w.saturating_mul(draw_h)).max(1) / img_h.max(1);
            }
            draw_w = draw_w.max(1).min(avail_w);
            draw_h = draw_h.max(1).min(avail_h);

            let start_x = view.x + ((view.width as i32 - draw_w as i32) / 2);
            let start_y = view.y + ((view.height as i32 - draw_h as i32) / 2);

            self.fill_rect(
                Rect::new(
                    start_x - 2,
                    start_y - 2,
                    (draw_w + 4) as u32,
                    (draw_h + 4) as u32,
                ),
                Color(0xD4DDE6),
            );

            for dy in 0..draw_h {
                let sy = dy.saturating_mul(img_h) / draw_h.max(1);
                for dx in 0..draw_w {
                    let sx = dx.saturating_mul(img_w) / draw_w.max(1);
                    let src_idx = sy.saturating_mul(img_w).saturating_add(sx);
                    if src_idx >= self.image_viewer_pixels.len() {
                        continue;
                    }
                    let color = self.image_viewer_pixels[src_idx];
                    self.draw_pixel(
                        (start_x + dx as i32).max(0) as u32,
                        (start_y + dy as i32).max(0) as u32,
                        Color(color),
                    );
                }
            }
        } else {
            self.draw_text(
                (view.x + 14).max(0) as u32,
                (view.y + 16).max(0) as u32,
                b"Open a PNG file from Explorer to preview it here.",
                Color(0x5D6F80),
            );
        }

        let status_y = (content_h - IMAGE_VIEWER_STATUS_H).max(0);
        self.fill_rect(
            Rect::new(0, status_y, self.rect.width, IMAGE_VIEWER_STATUS_H as u32),
            Color(0xDDE6EF),
        );
        self.fill_rect(Rect::new(0, status_y, self.rect.width, 1), Color(0xA3B8CC));
        let status_trim = Self::trim_label(self.image_viewer_status.as_str(), 80);
        self.draw_text(8, (status_y + 10) as u32, status_trim.as_bytes(), Color(0x2B4258));
    }

    pub fn render_settings(&mut self) {
        if self.kind != WindowKind::Settings {
            return;
        }

        let content_h = self.content_height();
        if content_h <= 0 {
            return;
        }

        // Background
        self.fill_rect(Rect::new(0, 0, self.rect.width, content_h as u32), Color(0xF2F2F2));

        // Header
        self.fill_rect(Rect::new(0, 0, self.rect.width, 40), Color(0x34495E));
        self.draw_text(15, 15, b"Configuracion del Sistema", Color(0xFFFFFF));

        let mut y = 60;

        // Section: System Info
        self.draw_text(15, y, b"Informacion de Software:", Color(0x2C3E50));
        y += 15;
        self.draw_text(25, y, b"- SO: ReduxOS v0.2.0 (Alpha)", Color(0x555555));
        y += 12;
        self.draw_text(25, y, b"- Kernel: x86_64 Microkernel", Color(0x555555));
        y += 25;

        // Section: Memory Info
        self.draw_text(15, y, b"Memoria RAM (Heap):", Color(0x2C3E50));
        y += 15;
        let heap_bytes = crate::allocator::heap_size_bytes();
        let heap_mib = heap_bytes / (1024 * 1024);
        let heap_task_reserved = crate::allocator::heap_reserved_bytes();
        let heap_task_reserved_mib = heap_task_reserved / (1024 * 1024);
        self.draw_text(
            25,
            y,
            alloc::format!("- Total Reservada: {} MB", heap_mib).as_bytes(),
            Color(0x555555),
        );
        y += 12;
        self.draw_text(
            25,
            y,
            alloc::format!("- Reservada por tareas: {} MB", heap_task_reserved_mib).as_bytes(),
            Color(0x555555),
        );
        y += 12;
        self.draw_text(25, y, b"- Estado: Activo", Color(0x555555));
        y += 25;

        // Section: Network Info
        self.draw_text(15, y, b"Estado de Red:", Color(0x2C3E50));
        y += 15;
        
        let has_net = unsafe { crate::net::IFACE.is_some() };
        let intel_model = crate::intel_net::get_model_name();
        let link_up = crate::intel_net::is_link_up();
        let active_transport = crate::net::get_active_transport();
        let failover_policy = crate::net::get_failover_policy();
        let ip_mode = crate::net::get_network_mode();
        let https_mode = crate::net::get_https_mode();
        let (s_ip, s_prefix, s_gw) = crate::net::get_static_ipv4_config();
        let wifi_model = crate::intel_wifi::get_model_name();
        let wifi_status = crate::intel_wifi::get_status();
        let wifi_datapath_ready = crate::intel_wifi::is_data_path_ready();
        let wifi_fw_hint = crate::intel_wifi::firmware_hint();

        self.draw_text(
            25,
            y,
            alloc::format!("- Transporte activo: {}", active_transport).as_bytes(),
            Color(0x34495E),
        );
        y += 12;
        self.draw_text(
            25,
            y,
            alloc::format!("- Failover: {}", failover_policy).as_bytes(),
            Color(0x34495E),
        );
        y += 12;
        self.draw_text(
            25,
            y,
            alloc::format!("- Modo IP: {}", ip_mode).as_bytes(),
            Color(0x34495E),
        );
        y += 12;
        self.draw_text(
            25,
            y,
            alloc::format!("- HTTPS: {}", https_mode).as_bytes(),
            Color(0x34495E),
        );
        y += 12;
        self.draw_text(
            25,
            y,
            alloc::format!(
                "- Perfil fija: {}.{}.{}.{}/{} gw {}.{}.{}.{}",
                s_ip[0], s_ip[1], s_ip[2], s_ip[3], s_prefix, s_gw[0], s_gw[1], s_gw[2], s_gw[3]
            )
            .as_bytes(),
            Color(0x34495E),
        );
        y += 12;

        if let Some(name) = intel_model {
            self.draw_text(25, y, alloc::format!("- Interfaz: {}", name).as_bytes(), Color(0x27AE60));
            y += 12;
            
            // Link Status with Color
            let link_color = if link_up { Color(0x27AE60) } else { Color(0xC0392B) };
            let link_text = if link_up { "Conectado (Enlace OK)" } else { "Sin Cable (Link Down)" };
            self.draw_text(25, y, alloc::format!("- Enlace: {}", link_text).as_bytes(), link_color);
            y += 12;

            if let Some(mac) = crate::intel_net::get_mac_address() {
                let mac_str = alloc::format!("- MAC: {:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}", 
                    mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
                self.draw_text(25, y, mac_str.as_bytes(), Color(0x555555));
                y += 12;
            }

            // IP Address info
            let dhcp_status = unsafe { crate::net::DHCP_STATUS };
            self.draw_text(25, y, alloc::format!("- DHCP: {}", dhcp_status).as_bytes(), Color(0x34495E));
            y += 12;

            if let Some(ip) = crate::net::get_ip_address() {
                self.draw_text(25, y, alloc::format!("- IP: {}", ip).as_bytes(), Color(0x2980B9));
                y += 12;
            }
            if let Some(gw) = crate::net::get_gateway() {
                self.draw_text(25, y, alloc::format!("- Gateway: {}", gw).as_bytes(), Color(0x555555));
                y += 12;
            }

            // Packet stats
            let (rx, tx) = crate::net::get_packet_stats();
            self.draw_text(25, y, alloc::format!("- Paquetes: RX: {} | TX: {}", rx, tx).as_bytes(), Color(0x555555));
            y += 12;

            if let Some(wifi_name) = wifi_model {
                self.draw_text(
                    25,
                    y,
                    alloc::format!(
                        "- WiFi: {} ({}, datapath={})",
                        wifi_name,
                        wifi_status,
                        if wifi_datapath_ready { "ready" } else { "pending" }
                    )
                    .as_bytes(),
                    Color(0x8E44AD),
                );
                y += 12;
                if let Some(hint) = wifi_fw_hint {
                    self.draw_text(
                        25,
                        y,
                        alloc::format!("- WiFi FW: {}", hint).as_bytes(),
                        Color(0x7F8C8D),
                    );
                    y += 12;
                }
            }
        } else if has_net {
            self.draw_text(25, y, b"- Interfaz: VirtIO Ethernet", Color(0x27AE60));
            y += 12;
            let dhcp_status = unsafe { crate::net::DHCP_STATUS };
            self.draw_text(25, y, alloc::format!("- DHCP: {}", dhcp_status).as_bytes(), Color(0x555555));
            y += 12;
            if let Some(ip) = crate::net::get_ip_address() {
                self.draw_text(25, y, alloc::format!("- IP: {}", ip).as_bytes(), Color(0x2980B9));
                y += 12;
            }
            self.draw_text(25, y, b"- Estado: Conectado", Color(0x555555));
            y += 12;

            if let Some(wifi_name) = wifi_model {
                self.draw_text(
                    25,
                    y,
                    alloc::format!(
                        "- WiFi: {} ({}, datapath={})",
                        wifi_name,
                        wifi_status,
                        if wifi_datapath_ready { "ready" } else { "pending" }
                    )
                    .as_bytes(),
                    Color(0x8E44AD),
                );
                y += 12;
                if let Some(hint) = wifi_fw_hint {
                    self.draw_text(
                        25,
                        y,
                        alloc::format!("- WiFi FW: {}", hint).as_bytes(),
                        Color(0x7F8C8D),
                    );
                    y += 12;
                }
            }
        } else {
            if let Some(wifi_name) = wifi_model {
                self.draw_text(25, y, b"- Interfaz LAN: No encontrada", Color(0xC0392B));
                y += 12;
                self.draw_text(
                    25,
                    y,
                    alloc::format!(
                        "- WiFi: {} ({}, datapath={})",
                        wifi_name,
                        wifi_status,
                        if wifi_datapath_ready { "ready" } else { "pending" }
                    )
                    .as_bytes(),
                    Color(0x8E44AD),
                );
                y += 12;
                if let Some(hint) = wifi_fw_hint {
                    self.draw_text(
                        25,
                        y,
                        alloc::format!("- WiFi FW: {}", hint).as_bytes(),
                        Color(0x7F8C8D),
                    );
                    y += 12;
                }
            } else {
                self.draw_text(25, y, b"- Interfaz: No encontrada", Color(0xC0392B));
                y += 12;
            }
            self.draw_text(25, y, b"- Estado: Desconectado", Color(0x555555));
        }
        y += 25;

        // Hardware Notice
        let hy = y as i32;
        self.fill_rect(Rect::new(15, hy, self.rect.width.saturating_sub(30), 60), Color(0xECF0F1));
        self.draw_border(Rect::new(15, hy, self.rect.width.saturating_sub(30), 60), Color(0xBDC3C7));
        self.draw_text(20, (hy + 12) as u32, b"Informacion de Hardware:", Color(0x2C3E50));
        
        if intel_model.is_some() || wifi_model.is_some() {
             self.draw_text(20, (hy + 28) as u32, b"Estado: Hardware de red detectado (modo experimental).", Color(0x27AE60));
             if let Some(wifi_name) = wifi_model {
                 self.draw_text(20, (hy + 42) as u32, alloc::format!("WiFi: {}", wifi_name).as_bytes(), Color(0x8E44AD));
             }
        } else {
             self.draw_text(20, (hy + 28) as u32, b"Placa: ASUS ROG MAXIMUS Z890 HERO", Color(0x7F8C8D));
             self.draw_text(20, (hy + 42) as u32, b"Nota: Se requieren drivers Intel i226 para LAN.", Color(0x7F8C8D));
        }
    }

    pub fn render_app_runner(&mut self) {
        if self.kind != WindowKind::AppRunner {
            return;
        }

        let content_h = self.content_height();
        if content_h <= 0 {
            return;
        }

        self.fill_rect(
            Rect::new(0, 0, self.rect.width, content_h as u32),
            Color(self.app_runner_background_color),
        );
        self.fill_rect(
            Rect::new(0, 0, self.rect.width, APP_RUNNER_TOP_H as u32),
            Color(0x1E2D3C),
        );
        self.fill_rect(
            Rect::new(0, APP_RUNNER_TOP_H - 1, self.rect.width, 1),
            Color(0x5A7288),
        );

        self.draw_text(10, 9, b"APP RUNNER", Color(0xE9F6FF));
        let src_trim = Self::trim_label(self.app_runner_source_file.as_str(), 64);
        self.draw_text(10, 21, src_trim.as_bytes(), Color(0xBFD8EE));
        let theme_line = alloc::format!("Theme: {}", self.app_runner_theme);
        let theme_trim = Self::trim_label(theme_line.as_str(), 60);
        self.draw_text(10, 33, theme_trim.as_bytes(), Color(0xA9C6DE));

        let canvas = self.app_runner_canvas_rect();
        self.fill_rect(canvas, Color(0xFFFFFF));
        self.draw_border(canvas, Color(0x9CB2C8));

        let inner = Rect::new(
            canvas.x + 10,
            canvas.y + 10,
            canvas.width.saturating_sub(20),
            canvas.height.saturating_sub(20),
        );
        self.fill_rect(inner, Color(self.app_runner_background_color));
        self.draw_border(inner, Color(0xC5D4E2));

        let max_cols = ((inner.width as i32 - 16).max(6) / 6) as usize;

        let header_trim = Self::trim_label(self.app_runner_header_text.as_str(), max_cols);
        self.draw_text(
            (inner.x + 8).max(0) as u32,
            (inner.y + 10).max(0) as u32,
            header_trim.as_bytes(),
            Color(self.app_runner_header_color),
        );

        let body_lines = Self::wrap_text_lines(self.app_runner_body_text.as_str(), max_cols, 7);
        let mut body_y = inner.y + 28;
        for line in body_lines.iter() {
            self.draw_text(
                (inner.x + 8).max(0) as u32,
                body_y.max(0) as u32,
                line.as_bytes(),
                Color(self.app_runner_body_color),
            );
            body_y += 10;
        }

        let btn_w = ((inner.width as i32 / 3).clamp(90, 220)) as u32;
        let btn_h = 26u32;
        let btn_x = inner.x + ((inner.width as i32 - btn_w as i32) / 2);
        let mut btn_y = inner.y + inner.height as i32 - btn_h as i32 - 14;
        let min_btn_y = inner.y + 34;
        if btn_y < min_btn_y {
            btn_y = min_btn_y;
        }
        let button_rect = Rect::new(btn_x, btn_y, btn_w, btn_h);
        self.fill_rect(button_rect, Color(self.app_runner_button_color));
        self.draw_border(button_rect, Color(0x1D3247));
        let btn_label_trim =
            Self::trim_label(self.app_runner_button_label.as_str(), (btn_w as usize / 6).saturating_sub(2));
        let text_x = button_rect.x + ((button_rect.width as i32 - (btn_label_trim.len() as i32 * 6)) / 2);
        self.draw_text(
            text_x.max(0) as u32,
            (button_rect.y + 9).max(0) as u32,
            btn_label_trim.as_bytes(),
            Color(0xFFFFFF),
        );

        let status_y = (content_h - APP_RUNNER_STATUS_H).max(0);
        self.fill_rect(
            Rect::new(0, status_y, self.rect.width, APP_RUNNER_STATUS_H as u32),
            Color(0xDEE9F3),
        );
        self.fill_rect(Rect::new(0, status_y, self.rect.width, 1), Color(0xA9BFD3));
        let status_trim = Self::trim_label(self.app_runner_status.as_str(), 80);
        self.draw_text(8, (status_y + 10) as u32, status_trim.as_bytes(), Color(0x294359));
    }

    pub fn render_doom_launcher(&mut self) {
        if self.kind != WindowKind::DoomLauncher {
            return;
        }

        let content_h = self.content_height();
        if content_h <= 0 {
            return;
        }

        self.fill_rect(Rect::new(0, 0, self.rect.width, content_h as u32), Color(0x111619));
        self.fill_rect(
            Rect::new(0, 0, self.rect.width, DOOM_LAUNCHER_TOP_H as u32),
            Color(0x2A1717),
        );
        self.fill_rect(
            Rect::new(0, DOOM_LAUNCHER_TOP_H - 1, self.rect.width, 1),
            Color(0x6E3333),
        );

        self.draw_text(10, 10, b"DOOM LAUNCHER", Color(0xFFE3D0));
        self.draw_text(10, 23, b"UEFI executable expected on USB/boot disk", Color(0xD7B9A5));
        self.draw_text(
            10,
            35,
            b"Paths: \\EFI\\DOOM\\DOOMX64.EFI or \\EFI\\DOOM\\BOOTX64.EFI",
            Color(0xC6A695),
        );

        let canvas = self.doom_launcher_canvas_rect();
        self.fill_rect(canvas, Color(0x1A2126));
        self.draw_border(canvas, Color(0x445765));

        self.draw_text(
            (canvas.x + 12).max(0) as u32,
            (canvas.y + 12).max(0) as u32,
            b"Click to launch DOOM in a separate UEFI app session.",
            Color(0xD8E6EF),
        );
        self.draw_text(
            (canvas.x + 12).max(0) as u32,
            (canvas.y + 24).max(0) as u32,
            b"After exit, control returns to ReduxOS GUI.",
            Color(0x9FB6C7),
        );

        let btn = self.doom_launch_button_rect();
        self.fill_rect(btn, Color(0xC23B22));
        self.draw_border(btn, Color(0x5C140B));
        self.draw_text(
            (btn.x + 36).max(0) as u32,
            (btn.y + 12).max(0) as u32,
            b"INICIAR DOOM",
            Color(0xFFFFFF),
        );

        let status_rect = self.doom_status_rect();
        self.fill_rect(status_rect, Color(0x172128));
        self.fill_rect(
            Rect::new(status_rect.x, status_rect.y, status_rect.width, 1),
            Color(0x415261),
        );
        let status_trim = Self::trim_label(self.doom_status.as_str(), 82);
        self.draw_text(
            (status_rect.x + 8).max(0) as u32,
            (status_rect.y + 10).max(0) as u32,
            status_trim.as_bytes(),
            Color(0xCFE4F2),
        );
    }

    pub fn render_linux_bridge(&mut self) {
        if self.kind != WindowKind::LinuxBridge {
            return;
        }

        let content_h = self.content_height();
        if content_h <= 0 {
            return;
        }

        self.fill_rect(Rect::new(0, 0, self.rect.width, content_h as u32), Color(0x0D1620));
        self.fill_rect(Rect::new(0, 0, self.rect.width, LINUX_BRIDGE_TOP_H as u32), Color(0x162838));
        self.fill_rect(
            Rect::new(0, LINUX_BRIDGE_TOP_H - 1, self.rect.width, 1),
            Color(0x3F5F79),
        );

        self.draw_text(10, 10, b"LINUX BRIDGE", Color(0xE2F2FF));
        let src_trim = Self::trim_label(self.linux_bridge_source.as_str(), 62);
        self.draw_text(10, 23, src_trim.as_bytes(), Color(0xB8D4EA));
        let info = if self.linux_bridge_width == 0 || self.linux_bridge_height == 0 {
            String::from("Sin frame")
        } else {
            alloc::format!("{}x{} px", self.linux_bridge_width, self.linux_bridge_height)
        };
        self.draw_text(10, 35, info.as_bytes(), Color(0x9AC0DE));

        let canvas = self.linux_bridge_canvas_rect();
        self.fill_rect(canvas, Color(0x09131C));
        self.draw_border(canvas, Color(0x365067));

        let img_w = self.linux_bridge_width as usize;
        let img_h = self.linux_bridge_height as usize;
        if img_w > 0
            && img_h > 0
            && self.linux_bridge_pixels.len() >= img_w.saturating_mul(img_h)
        {
            let avail_w = (canvas.width as i32 - 10).max(1) as usize;
            let avail_h = (canvas.height as i32 - 10).max(1) as usize;

            let mut draw_w = avail_w;
            let mut draw_h = (img_h.saturating_mul(draw_w)).max(1) / img_w.max(1);
            if draw_h > avail_h {
                draw_h = avail_h;
                draw_w = (img_w.saturating_mul(draw_h)).max(1) / img_h.max(1);
            }
            draw_w = draw_w.max(1).min(avail_w);
            draw_h = draw_h.max(1).min(avail_h);

            let start_x = canvas.x + ((canvas.width as i32 - draw_w as i32) / 2);
            let start_y = canvas.y + ((canvas.height as i32 - draw_h as i32) / 2);

            for dy in 0..draw_h {
                let sy = dy.saturating_mul(img_h) / draw_h.max(1);
                for dx in 0..draw_w {
                    let sx = dx.saturating_mul(img_w) / draw_w.max(1);
                    let src_idx = sy.saturating_mul(img_w).saturating_add(sx);
                    if src_idx >= self.linux_bridge_pixels.len() {
                        continue;
                    }
                    self.draw_pixel(
                        (start_x + dx as i32).max(0) as u32,
                        (start_y + dy as i32).max(0) as u32,
                        Color(self.linux_bridge_pixels[src_idx]),
                    );
                }
            }
        } else {
            self.draw_text(
                (canvas.x + 10).max(0) as u32,
                (canvas.y + 14).max(0) as u32,
                b"Esperando salida grafica Linux (SDL/X11 subset).",
                Color(0x7FA1BE),
            );
        }

        let status_rect = self.linux_bridge_status_rect();
        self.fill_rect(status_rect, Color(0x12202D));
        self.fill_rect(
            Rect::new(status_rect.x, status_rect.y, status_rect.width, 1),
            Color(0x365067),
        );
        let status_trim = Self::trim_label(self.linux_bridge_status.as_str(), 82);
        self.draw_text(
            (status_rect.x + 8).max(0) as u32,
            (status_rect.y + 10).max(0) as u32,
            status_trim.as_bytes(),
            Color(0xCCE6FA),
        );
    }

    pub fn set_explorer_home(&mut self) {
        if self.kind != WindowKind::Explorer {
            return;
        }

        self.explorer_current_cluster = 0;
        self.explorer_device_index = None;
        self.explorer_path = String::from("Quick Access");
        self.explorer_status = String::from("Select a storage volume to browse FAT32.");
        self.explorer_preview_lines.clear();
        self.explorer_items = alloc::vec![
            ExplorerItem::new("Desktop", ExplorerItemKind::ShortcutDesktop, 0, 0),
            ExplorerItem::new("Downloads", ExplorerItemKind::ShortcutDownloads, 0, 0),
            ExplorerItem::new("Documents", ExplorerItemKind::ShortcutDocuments, 0, 0),
            ExplorerItem::new("Images", ExplorerItemKind::ShortcutImages, 0, 0),
            ExplorerItem::new("Videos", ExplorerItemKind::ShortcutVideos, 0, 0),
            ExplorerItem::new("Storage", ExplorerItemKind::ShortcutUsb, 0, 0),
        ];

        self.render();
    }

    pub fn set_explorer_listing(
        &mut self,
        path: &str,
        cluster: u32,
        device_index: Option<usize>,
        items: Vec<ExplorerItem>,
    ) {
        if self.kind != WindowKind::Explorer {
            return;
        }

        self.explorer_path = String::from(path);
        self.explorer_current_cluster = cluster;
        self.explorer_device_index = device_index;
        self.explorer_items = items;
        self.explorer_preview_lines.clear();
        self.render();
    }

    pub fn set_explorer_status(&mut self, status: &str) {
        if self.kind != WindowKind::Explorer {
            return;
        }
        self.explorer_status = String::from(status);
        self.render();
    }

    pub fn set_explorer_preview(&mut self, status: &str, preview_lines: Vec<String>) {
        if self.kind != WindowKind::Explorer {
            return;
        }
        self.explorer_status = String::from(status);
        self.explorer_preview_lines = preview_lines;
        self.render();
    }

    pub fn load_image_viewer(
        &mut self,
        file_name: &str,
        width: u32,
        height: u32,
        pixels: Vec<u32>,
        status: &str,
    ) {
        if self.kind != WindowKind::ImageViewer {
            return;
        }
        self.image_viewer_file_name = String::from(file_name);
        self.image_viewer_width = width;
        self.image_viewer_height = height;
        self.image_viewer_pixels = pixels;
        self.image_viewer_status = String::from(status);
        self.render();
    }

    pub fn load_app_runner_layout(
        &mut self,
        source_file: &str,
        theme: &str,
        header_text: &str,
        body_text: &str,
        button_label: &str,
        background_color: u32,
        header_color: u32,
        body_color: u32,
        button_color: u32,
        status: &str,
    ) {
        if self.kind != WindowKind::AppRunner {
            return;
        }
        self.app_runner_source_file = String::from(source_file);
        self.app_runner_theme = String::from(theme);
        self.app_runner_header_text = String::from(header_text);
        self.app_runner_body_text = String::from(body_text);
        self.app_runner_button_label = String::from(button_label);
        self.app_runner_background_color = background_color;
        self.app_runner_header_color = header_color;
        self.app_runner_body_color = body_color;
        self.app_runner_button_color = button_color;
        self.app_runner_status = String::from(status);
        self.render();
    }

    pub fn set_doom_status(&mut self, status: &str) {
        if self.kind != WindowKind::DoomLauncher {
            return;
        }
        self.doom_status = String::from(status);
        self.render();
    }

    pub fn set_linux_bridge_status(&mut self, status: &str) {
        if self.kind != WindowKind::LinuxBridge {
            return;
        }
        self.linux_bridge_status = String::from(status);
        self.render();
    }

    pub fn set_linux_bridge_frame(
        &mut self,
        source: &str,
        width: u32,
        height: u32,
        pixels: Vec<u32>,
        status: &str,
    ) {
        if self.kind != WindowKind::LinuxBridge {
            return;
        }
        self.linux_bridge_source = String::from(source);
        self.linux_bridge_width = width;
        self.linux_bridge_height = height;
        self.linux_bridge_pixels = pixels;
        self.linux_bridge_status = String::from(status);
        self.render();
    }

    pub fn doom_launch_clicked(&self, global_x: i32, global_y: i32) -> bool {
        if self.kind != WindowKind::DoomLauncher {
            return false;
        }

        let local_x = global_x - self.rect.x;
        let local_y = global_y - (self.rect.y + TITLE_BAR_H);
        if local_x < 0 || local_y < 0 {
            return false;
        }

        self.doom_launch_button_rect()
            .contains(crate::gui::Point { x: local_x, y: local_y })
    }

    pub fn explorer_item_at(&self, global_x: i32, global_y: i32) -> Option<ExplorerItem> {
        if self.kind != WindowKind::Explorer {
            return None;
        }

        let local_x = global_x - self.rect.x;
        let local_y = global_y - (self.rect.y + TITLE_BAR_H);
        if local_x < 0 || local_y < 0 {
            return None;
        }

        let content_h = self.content_height();
        if local_x >= self.rect.width as i32 || local_y >= content_h {
            return None;
        }

        for (idx, item) in self.explorer_items.iter().enumerate() {
            let Some(icon_rect) = self.explorer_icon_rect(idx) else {
                continue;
            };
            if icon_rect.contains(crate::gui::Point { x: local_x, y: local_y }) {
                return Some(item.clone());
            }
        }

        None
    }

    pub fn explorer_item_global_rect(&self, index: usize) -> Option<Rect> {
        if self.kind != WindowKind::Explorer {
            return None;
        }

        let local = self.explorer_icon_rect(index)?;
        Some(Rect::new(
            self.rect.x + local.x,
            self.rect.y + TITLE_BAR_H + local.y,
            local.width,
            local.height,
        ))
    }

    pub fn explorer_canvas_contains(&self, global_x: i32, global_y: i32) -> bool {
        if self.kind != WindowKind::Explorer {
            return false;
        }

        let local_x = global_x - self.rect.x;
        let local_y = global_y - (self.rect.y + TITLE_BAR_H);
        if local_x < 0 || local_y < 0 {
            return false;
        }
        if local_x >= self.rect.width as i32 || local_y >= self.content_height() {
            return false;
        }

        let status_top = self.content_height() - EXPLORER_STATUS_H;
        if status_top <= EXPLORER_TOP_H {
            return false;
        }

        local_y >= EXPLORER_TOP_H && local_y < status_top
    }

    pub fn load_notepad_document(
        &mut self,
        dir_cluster: u32,
        dir_path: &str,
        file_name: &str,
        text: &str,
        status: &str,
    ) {
        if self.kind != WindowKind::Notepad {
            return;
        }

        self.notepad_dir_cluster = dir_cluster;
        self.notepad_dir_path = String::from(dir_path);
        self.notepad_file_name = String::from(file_name);
        self.notepad_text = String::from(text);
        self.notepad_status = String::from(status);
        self.notepad_edit_name = false;
        self.render();
    }

    pub fn set_notepad_status(&mut self, status: &str) {
        if self.kind != WindowKind::Notepad {
            return;
        }
        self.notepad_status = String::from(status);
        self.render();
    }

    pub fn prepare_notepad_new(&mut self, default_name: &str) {
        if self.kind != WindowKind::Notepad {
            return;
        }

        self.notepad_file_name = String::from(default_name);
        self.notepad_text.clear();
        self.notepad_edit_name = true;
        self.notepad_status = String::from("New file. Type a name and edit text.");
        self.render();
    }

    pub fn set_notepad_filename_focus(&mut self, focus: bool) {
        if self.kind != WindowKind::Notepad {
            return;
        }
        self.notepad_edit_name = focus;
        self.render();
    }

    pub fn notepad_action_at(&self, global_x: i32, global_y: i32) -> Option<NotepadClickAction> {
        if self.kind != WindowKind::Notepad {
            return None;
        }

        let local_x = global_x - self.rect.x;
        let local_y = global_y - (self.rect.y + TITLE_BAR_H);
        if local_x < 0 || local_y < 0 {
            return None;
        }
        if local_x >= self.rect.width as i32 || local_y >= self.content_height() {
            return None;
        }

        let p = crate::gui::Point {
            x: local_x,
            y: local_y,
        };

        let new_btn = self.notepad_button_rect(0);
        let save_btn = self.notepad_button_rect(1);
        let delete_btn = self.notepad_button_rect(2);
        let name_rect = self.notepad_filename_rect();
        let editor_rect = self.notepad_editor_rect();

        if new_btn.contains(p) {
            return Some(NotepadClickAction::New);
        }
        if save_btn.contains(p) {
            return Some(NotepadClickAction::Save);
        }
        if delete_btn.contains(p) {
            return Some(NotepadClickAction::Delete);
        }
        if name_rect.contains(p) {
            return Some(NotepadClickAction::FilenameField);
        }
        if editor_rect.contains(p) {
            return Some(NotepadClickAction::EditorArea);
        }

        None
    }

    pub fn browser_link_at(&self, global_x: i32, global_y: i32) -> Option<String> {
        if self.kind != WindowKind::Browser {
            return None;
        }

        let local_x = global_x - self.rect.x;
        let local_y = global_y - (self.rect.y + TITLE_BAR_H);
        if local_x < 0 || local_y < 0 {
            return None;
        }
        if local_x >= self.rect.width as i32 || local_y >= self.content_height() {
            return None;
        }

        let view_rect = self.browser_viewport_rect();
        if !view_rect.contains(crate::gui::Point {
            x: local_x,
            y: local_y,
        }) {
            return None;
        }

        let y_in_view = local_y - view_rect.y;
        let row = ((y_in_view - 4).max(0) / 10) as usize;

        let flat = self.browser_flat_lines();
        let visible_rows = self.browser_visible_rows();
        let max_scroll = flat.len().saturating_sub(visible_rows);
        let scroll = self.browser_scroll.min(max_scroll);
        let idx = scroll.saturating_add(row);
        if idx < flat.len() {
            return Self::extract_first_url_from_text(flat[idx].as_str());
        }

        None
    }

    pub fn browser_go_clicked(&self, global_x: i32, global_y: i32) -> bool {
        if self.kind != WindowKind::Browser {
            return false;
        }
        let local_x = global_x - self.rect.x;
        let local_y = global_y - (self.rect.y + TITLE_BAR_H);
        self.browser_go_rect()
            .contains(crate::gui::Point { x: local_x, y: local_y })
    }

    pub fn browser_back_clicked(&self, global_x: i32, global_y: i32) -> bool {
        if self.kind != WindowKind::Browser {
            return false;
        }
        let local_x = global_x - self.rect.x;
        let local_y = global_y - (self.rect.y + TITLE_BAR_H);
        Rect::new(10, 10, 24, 24).contains(crate::gui::Point {
            x: local_x,
            y: local_y,
        })
    }

    pub fn browser_forward_clicked(&self, global_x: i32, global_y: i32) -> bool {
        if self.kind != WindowKind::Browser {
            return false;
        }
        let local_x = global_x - self.rect.x;
        let local_y = global_y - (self.rect.y + TITLE_BAR_H);
        Rect::new(40, 10, 24, 24).contains(crate::gui::Point {
            x: local_x,
            y: local_y,
        })
    }

    pub fn browser_surface_point_at(
        &self,
        global_x: i32,
        global_y: i32,
    ) -> Option<(u32, u32)> {
        if self.kind != WindowKind::Browser {
            return None;
        }

        let local_x = global_x - self.rect.x;
        let local_y = global_y - (self.rect.y + TITLE_BAR_H);
        if local_x < 0 || local_y < 0 {
            return None;
        }
        if local_x >= self.rect.width as i32 || local_y >= self.content_height() {
            return None;
        }

        let view_rect = self.browser_viewport_rect();
        if !view_rect.contains(crate::gui::Point {
            x: local_x,
            y: local_y,
        }) {
            return None;
        }

        let surf_w = self.browser_surface_width as usize;
        let surf_h = self.browser_surface_height as usize;
        if surf_w == 0 || surf_h == 0 {
            return None;
        }
        if self.browser_surface_pixels.len() < surf_w.saturating_mul(surf_h) {
            return None;
        }

        let avail_w = (view_rect.width as i32 - 8).max(1) as usize;
        let avail_h = (view_rect.height as i32 - 8).max(1) as usize;

        let mut draw_w = avail_w;
        let mut draw_h = (surf_h.saturating_mul(draw_w)).max(1) / surf_w.max(1);
        if draw_h > avail_h {
            draw_h = avail_h;
            draw_w = (surf_w.saturating_mul(draw_h)).max(1) / surf_h.max(1);
        }
        draw_w = draw_w.max(1).min(avail_w);
        draw_h = draw_h.max(1).min(avail_h);

        let start_x = view_rect.x + ((view_rect.width as i32 - draw_w as i32) / 2);
        let start_y = view_rect.y + ((view_rect.height as i32 - draw_h as i32) / 2);

        let rel_x = local_x - start_x;
        let rel_y = local_y - start_y;
        if rel_x < 0 || rel_y < 0 || rel_x >= draw_w as i32 || rel_y >= draw_h as i32 {
            return None;
        }

        let src_x = ((rel_x as usize).saturating_mul(surf_w) / draw_w.max(1))
            .min(surf_w.saturating_sub(1)) as u32;
        let src_y = ((rel_y as usize).saturating_mul(surf_h) / draw_h.max(1))
            .min(surf_h.saturating_sub(1)) as u32;
        Some((src_x, src_y))
    }

    pub fn browser_scroll_clicked(&self, global_x: i32, global_y: i32) -> i32 {
        if self.kind != WindowKind::Browser {
            return 0;
        }

        let local_x = global_x - self.rect.x;
        let local_y = global_y - (self.rect.y + TITLE_BAR_H);
        let p = crate::gui::Point {
            x: local_x,
            y: local_y,
        };
        if self.browser_scroll_up_rect().contains(p) {
            return -1;
        }
        if self.browser_scroll_down_rect().contains(p) {
            return 1;
        }
        0
    }

    pub fn browser_scroll_by(&mut self, delta_rows: i32) -> bool {
        if self.kind != WindowKind::Browser {
            return false;
        }
        let max_scroll = self.browser_max_scroll() as i32;
        let before = self.browser_scroll as i32;
        let after = (before + delta_rows).clamp(0, max_scroll);
        if after == before {
            return false;
        }
        self.browser_scroll = after as usize;
        self.render();
        true
    }

    pub fn handle_char(&mut self, ch: char) {
        match self.kind {
            WindowKind::Terminal => {
                if ch.is_ascii() && !ch.is_control() {
                    self.input_buffer.push(ch);
                    self.render();
                }
            }
            WindowKind::Notepad => {
                if !ch.is_ascii() || ch.is_control() {
                    return;
                }

                if self.notepad_edit_name {
                    let b = ch as u8;
                    if (b.is_ascii_alphanumeric() || b == b'.' || b == b'_' || b == b'-')
                        && self.notepad_file_name.len() < 12
                    {
                        self.notepad_file_name.push(ch.to_ascii_uppercase());
                        self.render();
                    }
                } else {
                    self.notepad_text.push(ch);
                    self.render();
                }
            }
            WindowKind::Explorer => {}
            WindowKind::Browser => {
                if ch.is_ascii() && !ch.is_control() {
                    self.browser_url.push(ch);
                    self.render();
                }
            }
            WindowKind::ImageViewer => {}
            WindowKind::AppRunner => {}
            WindowKind::DoomLauncher => {}
            WindowKind::LinuxBridge => {}
            WindowKind::Settings => {}
        }
    }

    pub fn handle_backspace(&mut self) {
        match self.kind {
            WindowKind::Terminal => {
                if !self.input_buffer.is_empty() {
                    self.input_buffer.pop();
                    self.render();
                }
            }
            WindowKind::Notepad => {
                if self.notepad_edit_name {
                    if !self.notepad_file_name.is_empty() {
                        self.notepad_file_name.pop();
                        self.render();
                    }
                } else if !self.notepad_text.is_empty() {
                    self.notepad_text.pop();
                    self.render();
                }
            }
            WindowKind::Explorer => {}
            WindowKind::Browser => {
                if !self.browser_url.is_empty() {
                    self.browser_url.pop();
                    self.render();
                }
            }
            WindowKind::ImageViewer => {}
            WindowKind::AppRunner => {}
            WindowKind::DoomLauncher => {}
            WindowKind::LinuxBridge => {}
            WindowKind::Settings => {}
        }
    }

    pub fn handle_enter(&mut self) -> Option<String> {
        match self.kind {
            WindowKind::Terminal => {
                if self.input_buffer.is_empty() {
                    return None;
                }

                let cmd = self.input_buffer.clone();
                let full_prompt = alloc::format!("{}> {}", self.current_path, cmd);
                self.output_lines.push(full_prompt);
                self.input_buffer.clear();
                self.render();
                Some(cmd)
            }
            WindowKind::Notepad => {
                if self.notepad_edit_name {
                    self.notepad_edit_name = false;
                    self.notepad_status = String::from("Filename set.");
                } else {
                    self.notepad_text.push('\n');
                }
                self.render();
                None
            }
            WindowKind::Explorer => None,
            WindowKind::Browser => {
                if self.browser_url.trim().is_empty() {
                    None
                } else {
                    Some(self.browser_url.clone())
                }
            }
            WindowKind::ImageViewer => None,
            WindowKind::AppRunner => None,
            WindowKind::DoomLauncher => None,
            WindowKind::LinuxBridge => None,
            WindowKind::Settings => None,
        }
    }

    pub fn add_output(&mut self, line: &str) {
        if self.kind != WindowKind::Terminal {
            return;
        }

        self.output_lines.push(String::from(line));

        if self.output_lines.len() > 30 {
            self.output_lines.remove(0);
        }

        self.render();
    }
}
